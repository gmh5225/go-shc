package main

import (
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"

	goshc "github.com/strazzere/go-shc/pkg"
)

var (
	destFlag    string
)

func main() {
	flag.Usage = func() {
		fmt.Fprint(os.Stderr, `Usage: goshc-gen SCRIPT

Options:
`)
		flag.PrintDefaults()
	}
	flag.StringVar(&destFlag, "dest", "",
		"`path` where binaries and go file are written to, defaults to a safely construction path based on script name",
	)
	flag.Parse()
	if flag.NArg() != 1 {
		flag.Usage()
		os.Exit(2)
	}
	if err := buildLoader(flag.Arg(0)); err != nil {
		fmt.Fprintf(os.Stderr, "error: %s\n", err)
		os.Exit(127)
	}
	compile(fmt.Sprintf("%s.x", flag.Arg(0)), true)
}

func compile(outname string, garble bool) {
	goCmd := "go"
	prebuildFlags := ""
	postBuildFlags := `-ldflags "-s"`
	if garble {
		goCmd = "garble"
		prebuildFlags = "-tiny -literal"
		postBuildFlags := ""
	}
	cmd, err := exec.Command(fmt.Sprintf(`GOOS=linux GOARCH=386 %s %s build -o %s %s ./gen/shc.go`, goCmd, prebuildFlags, postBuildFlags outname)).Output()
	if err != nil {
		fmt.Printf("error %s", err)
		return
	}
	output := string(cmd)
	fmt.Print(output)
}

func buildLoader(script string) error {
	if destFlag == "" {
		destFlag = "gen"
	}

	err := os.MkdirAll(destFlag, 0o755)
	if err != nil && !os.IsExist(err) {
		return err
	}
	output, err = os.OpenFile(
		filepath.Join(destFlag, "shc.go"),
		os.O_CREATE|os.O_WRONLY|os.O_TRUNC,
		0o644,
	)
	if err != nil {
		return err
	}

	payloadBytes, err := os.ReadFile(script)
	if err != nil {
		fmt.Printf("Error loading payload : %v", err)
		return err
	}

	key := []byte("DERPY")

	goshc.Crypt(payloadBytes, key)

	write("// Code generated by goshc-gen. DO NOT EDIT." + "\n" +
		"package main" + "\n" +
		"" + "\n" +
		"import (" + "\n" +
		`	"fmt"` + "\n" +
		"" + "\n" +
		`	"os/exec"` + "\n" +
		`	goshc "github.com/strazzere/go-shc/pkg"` + "\n" +
		")" + "\n" +
		"" + "\n" +
		"var (" + "\n" +
		"	payload = []byte{" + goshc.ToGoString(payloadBytes) + " }" + "\n" +
		"	key     = []byte{" + goshc.ToGoString(key) + "}" + "\n" +
		")" + "\n" +
		"" + "\n" +
		"//garble:controlflow" + "\n" +
		"func main() {" + "\n" +
		"	err := goshc.Crypt(payload, key)" + "\n" +
		"	if err != nil {" + "\n" +
		`		fmt.Printf("error %s", err)` + "\n" +
		"		return" + "\n" +
		"	}" + "\n" +
		"" + "\n" +
		"	file, err := goshc.MemOpen(payload)" + "\n" +
		"	if err != nil {" + "\n" +
		`		fmt.Printf("error %s", err)` + "\n" +
		"		return" + "\n" +
		"	}" + "\n" +
		"" + "\n" +
		"	cmd, err := exec.Command(file.Name()).Output()" + "\n" +
		"	if err != nil {" + "\n" +
		`		fmt.Printf("error %s", err)` + "\n" +
		"		return" + "\n" +
		"	}" + "\n" +
		"	output := string(cmd)" + "\n" +
		"" + "\n" +
		`	fmt.Printf("Output: \n<<<\n%v\n>>>", output)` + "\n" +
		"}")

	return nil
}

var output io.Writer

func write(strs ...string) {
	for _, str := range strs {
		if _, err := fmt.Fprint(output, str); err != nil {
			panic(err)
		}
	}
	if _, err := fmt.Fprintln(output); err != nil {
		panic(err)
	}
}
